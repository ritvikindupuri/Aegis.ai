import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

const NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0";

interface CVESearchParams {
  keyword?: string;
  cveId?: string;
  packageName?: string;
  startDate?: string;
  endDate?: string;
  severity?: string;
  limit?: number;
}

interface NVDCVEItem {
  id: string;
  sourceIdentifier: string;
  published: string;
  lastModified: string;
  vulnStatus: string;
  descriptions: Array<{ lang: string; value: string }>;
  metrics?: {
    cvssMetricV31?: Array<{
      cvssData: {
        baseScore: number;
        baseSeverity: string;
        vectorString: string;
      };
    }>;
    cvssMetricV2?: Array<{
      cvssData: {
        baseScore: number;
      };
    }>;
  };
  weaknesses?: Array<{
    description: Array<{ lang: string; value: string }>;
  }>;
  references?: Array<{
    url: string;
    source: string;
  }>;
}

interface ProcessedCVE {
  cve_id: string;
  description: string;
  published: string;
  severity: string;
  cvss_score: number | null;
  cvss_vector: string | null;
  weaknesses: string[];
  references: string[];
  status: string;
}

function processCVEItem(item: NVDCVEItem): ProcessedCVE {
  const cve = item;
  
  // Get English description
  const description = cve.descriptions?.find(d => d.lang === 'en')?.value || 
                     cve.descriptions?.[0]?.value || 
                     'No description available';
  
  // Get CVSS score (prefer v3.1, fallback to v2)
  let cvssScore: number | null = null;
  let severity = 'unknown';
  let cvssVector: string | null = null;
  
  if (cve.metrics?.cvssMetricV31?.[0]) {
    const metric = cve.metrics.cvssMetricV31[0];
    cvssScore = metric.cvssData.baseScore;
    severity = metric.cvssData.baseSeverity.toLowerCase();
    cvssVector = metric.cvssData.vectorString;
  } else if (cve.metrics?.cvssMetricV2?.[0]) {
    cvssScore = cve.metrics.cvssMetricV2[0].cvssData.baseScore;
    // Map CVSS v2 score to severity
    if (cvssScore >= 9.0) severity = 'critical';
    else if (cvssScore >= 7.0) severity = 'high';
    else if (cvssScore >= 4.0) severity = 'medium';
    else severity = 'low';
  }
  
  // Extract weaknesses (CWE IDs)
  const weaknesses: string[] = [];
  cve.weaknesses?.forEach(w => {
    w.description?.forEach(d => {
      if (d.value && d.value !== 'NVD-CWE-Other' && d.value !== 'NVD-CWE-noinfo') {
        weaknesses.push(d.value);
      }
    });
  });
  
  // Extract reference URLs
  const references = cve.references?.map(r => r.url) || [];
  
  return {
    cve_id: cve.id,
    description,
    published: cve.published,
    severity,
    cvss_score: cvssScore,
    cvss_vector: cvssVector,
    weaknesses,
    references: references.slice(0, 5), // Limit to 5 references
    status: cve.vulnStatus
  };
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const params = await req.json() as CVESearchParams;
    const { keyword, cveId, packageName, startDate, endDate, severity, limit = 20 } = params;
    
    console.log("NVD CVE Lookup request:", { keyword, cveId, packageName, severity });
    
    // Build NVD API URL
    const urlParams = new URLSearchParams();
    
    if (cveId) {
      // Direct CVE lookup
      urlParams.append('cveId', cveId);
    } else {
      // Keyword search
      const searchTerm = keyword || packageName;
      if (searchTerm) {
        urlParams.append('keywordSearch', searchTerm);
        urlParams.append('keywordExactMatch', 'false');
      }
      
      // Date range for recent CVEs
      if (startDate) {
        urlParams.append('pubStartDate', startDate);
      } else {
        // Default to last 30 days if no date specified
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        urlParams.append('pubStartDate', thirtyDaysAgo.toISOString());
      }
      
      if (endDate) {
        urlParams.append('pubEndDate', endDate);
      } else {
        urlParams.append('pubEndDate', new Date().toISOString());
      }
      
      // Severity filter
      if (severity && ['low', 'medium', 'high', 'critical'].includes(severity.toLowerCase())) {
        urlParams.append('cvssV3Severity', severity.toUpperCase());
      }
      
      urlParams.append('resultsPerPage', String(Math.min(limit, 100)));
    }
    
    const apiUrl = `${NVD_API_BASE}?${urlParams.toString()}`;
    console.log("Fetching from NVD:", apiUrl);
    
    // NVD API key is optional but increases rate limits
    const NVD_API_KEY = Deno.env.get("NVD_API_KEY");
    
    const headers: Record<string, string> = {
      "Accept": "application/json",
      "User-Agent": "AEGIS-Security-Platform/1.0"
    };
    
    if (NVD_API_KEY) {
      headers["apiKey"] = NVD_API_KEY;
    }
    
    const response = await fetch(apiUrl, { headers });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error("NVD API error:", response.status, errorText);
      
      if (response.status === 403) {
        throw new Error("NVD API rate limit exceeded. Try again later.");
      }
      if (response.status === 404) {
        return new Response(JSON.stringify({
          success: true,
          cves: [],
          total: 0,
          message: "No CVEs found matching the criteria"
        }), {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }
      throw new Error(`NVD API request failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    const vulnerabilities = data.vulnerabilities || [];
    const processedCVEs = vulnerabilities.map((v: { cve: NVDCVEItem }) => processCVEItem(v.cve));
    
    console.log(`Retrieved ${processedCVEs.length} CVEs from NVD`);
    
    return new Response(JSON.stringify({
      success: true,
      cves: processedCVEs,
      total: data.totalResults || processedCVEs.length,
      resultsPerPage: data.resultsPerPage || processedCVEs.length,
      timestamp: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
    
  } catch (error) {
    console.error("NVD CVE lookup error:", error);
    return new Response(JSON.stringify({ 
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
      cves: []
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
